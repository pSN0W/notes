This type of problem is easy to figure out you just need to find the recurrence and then save the result somewhere.

## Que
- [[decode_ways]]
- [[num_unique_bst]]
- [[buy_and_sell_stock_iii]]
- [[perfect_square_breaking]]
- [[stocks_with_cooldown]]
- [[counting_bits]]
- [[integer_break]]
- [[combination_sum]]
- [[count_number_with_unique_digits]]
- [[wiggle_subsequence]]
- [[coin_change_ii]]
- [[student_attendance_record]] -> solve it using PnC
- [[decode_ways_ii]]
- [[delete_and_earn]]
- [[maximal_square]]
- [[triplet_with_bitwise_and_0]]
- [[partition_for_max_sum]]
- [[book_shelf_ordering]]
- [[max_sum_divisible_by_3]]
- [[min_open_taps_to_water_garden]]
- [[regex_matching]]
- [[minimum_taps_to_water_garden]]
- [[count_all_valid_pickup_and_delivery]]
- [[stone_game_iii]]
- [[form_largest_integer_with_digits_that_sum_to_target]]
- [[stone_game_iv]]
# LCS Based
- https://leetcode.com/problems/maximum-length-of-repeated-subarray/ -> You just need to dp[i][j] = nums1[i] == nums2[j] ? 1 + dp[i + 1][j + 1] : 0;

# LIS Based
- [[longest_arithmetic_subsequence]]

## Unbounded Knapsack
