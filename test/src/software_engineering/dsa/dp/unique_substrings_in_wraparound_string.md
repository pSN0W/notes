# ðŸ§© Que
- [Link](https://leetcode.com/problems/unique-substrings-in-wraparound-string/)
We define the string base to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so base will look like this:

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".
Given a string s, return the number of unique non-empty substrings of s are present in base.
```ad-question
title: Test Case
Input: s = "zab"
Output: 6
Explanation: There are six substrings ("z", "a", "b", "za", "ab", and "zab") of s in base.
```

---
# Abstract
```ad-abstract
To find the longest substring ending at each index you can just take help of the previous index. It will just be dp[i] = 1 + dp[i-1] if i follows i-1. Now to get the unique ones you just need to find the longest for each character
```

- Tags #revise 
--- 
# ðŸ•µï¸â€â™‚ï¸ Main Logic
- The first one is pretty clear to check if two index follow each other just check if i-1 is z and i is a or ord(i) - ord(i-1) == 1
- The proof of second point is for a character consider `g` the substring will be same that means :
		- If somewhere it ends at `g` with length 2 then the longest substring will be `fg`
		- If it has length of 4 then `defg`
- So the maximum will cover all the substring generated by the other minimum ones
---
# â˜ ï¸ My thought process
- 
---

# ðŸ’» Code
```python
class Solution:
    def findSubstringInWraproundString(self, s: str) -> int:
        def follows_order(i):
            if s[i-1] == 'z' and s[i] == 'a':
                return True
            return ord(s[i]) - ord(s[i-1]) == 1

        n = len(s)
        dp = [1]*n
        for i in range(1,n):
            if follows_order(i):
                dp[i] = 1 + dp[i-1]
        mx_freq = [0]*26
        for i,ch in enumerate(s):
            mp = ord(ch)-ord('a')
            mx_freq[mp] = max(mx_freq[mp],dp[i])
        return sum(mx_freq)
```
---
