# 🧩 Que
- [Link](https://leetcode.com/problems/concatenated-words/)
Given a list of word. A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.
1 <= words.length <= 104
1 <= words[i].length <= 30
```ad-question
**Input:** words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
**Output:** ["catsdogcats","dogcatsdog","ratcatdogcat"]
**Explanation:** "catsdogcats" can be concatenated by "cats", "dog" and "cats"; 
"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
```

---
# Abstract
```ad-abstract
The idea here is to fact that the length of each word is really small. What you do for this question is that you iterate over each of the word and for each word you check if it can be generated by other word. To do this you have a dp array where dp[i] = word[:i] can be generated using concatenation of other word. To build the dp use j to iterate from [i..n] and check if word[i:j] is part of the words provided. 
```
One can use such algo for problems like [[word_break_ii]] too
- Tags #unsolved 
--- 
# 🕵️‍♂️ Main Logic
- Keep the words in a set for easy searching
- For each word do the following.
	- Create a dp array where dp[i] = if word[:i] can be formed using string concatenation. and mark dp[0] as True
	- if dp[i] is False then continue to next i
	- Now the next order of business is how can we go from i to mark other indices.
	- for j in [i..n]:
		- if word[i:j] is part of the given words or not if it is then mark dp[j] as true too.

---
# ☠️ My thought process
- 
---

# 💻 Code
```c++
class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        unordered_set<string> words_set;
        for (string word : words) words_set.insert(word);
        vector<string> res;
    
        for (string word : words) {
            int n = word.size();
            vector<int> dp(n + 1, 0);
            dp[0] = 1;
            for (int i = 0; i < n; i++) {
                if (!dp[i]) continue;
                for (int j = i + 1; j <= n; j++) {
                    if (j - i < n && words_set.count(word.substr(i, j - i))) {
                        dp[j] = 1;
                    }
                }
                if (dp[n]) {
                    res.push_back(word);
                    break;
                }
            }
        }
        return res;
    }
};
```
---
